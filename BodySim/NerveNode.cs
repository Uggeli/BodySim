namespace BodySim;

public class NerveNode : BodyPartNodeBase, IResourceNeedComponent, IResourceProductionComponent
{
    public Dictionary<BodyResourceType, float> ResourceNeeds { get; } = [];
    public Dictionary<BodyResourceType, float> ResourceProduction { get; } = [];

    // ── Pain ───────────────────────────────────────────────────────

    /// <summary>Current accumulated pain at this body part (0 = none). Decays each tick.</summary>
    public float PainLevel { get; set; }

    /// <summary>Pain above this threshold triggers overload (numbness / shock risk).</summary>
    public float PainOverloadThreshold { get; set; } = 80f;

    /// <summary>Natural pain decay rate per metabolic tick.</summary>
    public float PainDecayRate { get; set; } = 3f;

    // ── Signal ─────────────────────────────────────────────────────

    /// <summary>Whether this nerve is severed (disconnected from the network).</summary>
    public bool IsSevered { get; set; }

    /// <summary>Whether the nerve is overloaded from excessive pain (temporary numbness).</summary>
    public bool IsOverloaded { get; set; }

    /// <summary>Whether this node is part of the central nervous system (brain/spine).</summary>
    public bool IsCentral { get; init; }

    /// <summary>Whether this node is a major nerve hub (carries signals for many downstream parts).</summary>
    public bool IsMajorHub { get; init; }

    // ── Mana ───────────────────────────────────────────────────────

    /// <summary>Mana production rate per metabolic tick (magical energy generated by nerve activity).</summary>
    public float ManaProductionRate { get; set; }

    /// <summary>Base mana production — central nodes produce more.</summary>
    public float BaseManaProduction { get; init; }

    // ── Magical Heat ───────────────────────────────────────────────

    /// <summary>How much heat is generated per unit of mana produced.</summary>
    public float HeatPerMana { get; set; } = 1.5f;

    /// <summary>Natural heat dissipation rate per metabolic tick. Higher = cools faster.</summary>
    public float HeatDissipationRate { get; set; }

    /// <summary>Base dissipation — central/hub nodes dissipate faster (better blood flow).</summary>
    public float BaseHeatDissipation { get; init; }

    /// <summary>Heat above this threshold starts damaging the nerve each tick.</summary>
    public float HeatDamageThreshold { get; set; } = 50f;

    /// <summary>Whether this nerve is overheating (heat above damage threshold).</summary>
    public bool IsOverheated { get; set; }

    public NerveNode(BodyPartType bodyPartType, bool isCentral = false, bool isMajorHub = false)
        : base(bodyPartType, [
            new BodyComponentBase(100, 100, 0.2f, BodyComponentType.Health),
            new BodyComponentBase(100, 100, 0.3f, BodyComponentType.NerveSignal),
            new BodyComponentBase(0, 100, 0, BodyComponentType.Mana), // Mana starts at 0, produced over time
            new BodyComponentBase(0, 100, 0, BodyComponentType.MagicalHeat), // Heat starts at 0, generated by mana
        ])
    {
        IsCentral = isCentral;
        IsMajorHub = isMajorHub;

        // Central nodes (brain/spine) produce more mana and need more resources
        BaseManaProduction = isCentral ? 0.5f : (isMajorHub ? 0.3f : 0.1f);
        ManaProductionRate = BaseManaProduction;

        // Central/hub nodes dissipate heat faster (larger, better blood supply)
        BaseHeatDissipation = isCentral ? 3f : (isMajorHub ? 2f : 1f);
        HeatDissipationRate = BaseHeatDissipation;

        float metabolicMultiplier = isCentral ? 2f : (isMajorHub ? 1.3f : 1f);
        ResourceNeeds[BodyResourceType.Oxygen] = 0.1f * metabolicMultiplier;
        ResourceNeeds[BodyResourceType.Glucose] = 0.08f * metabolicMultiplier;
    }

    // ── Pain management ────────────────────────────────────────────

    /// <summary>Receives pain stimulus. Returns the effective pain felt (0 if severed/overloaded).</summary>
    public float ReceivePain(float incoming)
    {
        if (IsSevered || Status.HasFlag(SystemNodeStatus.Disabled)) return 0;

        // Overloaded nerves are numb — reduced pain reception
        float effective = IsOverloaded ? incoming * 0.2f : incoming;

        PainLevel = Math.Clamp(PainLevel + effective, 0, 100);

        // Check for overload
        if (PainLevel >= PainOverloadThreshold && !IsOverloaded)
        {
            IsOverloaded = true;
        }

        return effective;
    }

    /// <summary>Decays pain naturally each tick.</summary>
    public void DecayPain()
    {
        PainLevel = Math.Max(0, PainLevel - PainDecayRate);

        // Recover from overload when pain subsides
        if (IsOverloaded && PainLevel < PainOverloadThreshold * 0.5f)
        {
            IsOverloaded = false;
        }
    }

    /// <summary>Gets the current signal strength (0–1). Affects downstream communication.</summary>
    public float GetSignalStrength()
    {
        if (IsSevered || Status.HasFlag(SystemNodeStatus.Disabled)) return 0;

        float signal = GetComponent(BodyComponentType.NerveSignal)?.Current ?? 0;
        float health = GetComponent(BodyComponentType.Health)?.Current ?? 0;
        float signalPct = signal / 100f;
        float healthPct = health / 100f;

        // Overloaded nerves have reduced signal
        float overloadPenalty = IsOverloaded ? 0.5f : 1f;

        return signalPct * healthPct * overloadPenalty;
    }

    // ── Severing / Repair ──────────────────────────────────────────

    /// <summary>Severs the nerve — no signal, no pain routing downstream, no mana production.</summary>
    public void Sever()
    {
        IsSevered = true;
        ManaProductionRate = 0;

        // Signal drops to 0
        var signal = GetComponent(BodyComponentType.NerveSignal);
        if (signal != null) { signal.Current = 0; signal.RegenRate = 0; }

        // Mana production stops
        var mana = GetComponent(BodyComponentType.Mana);
        if (mana != null) mana.RegenRate = 0;
    }

    /// <summary>Repairs a severed nerve — begins slow recovery.</summary>
    public void Repair()
    {
        if (!IsSevered) return;

        IsSevered = false;

        // Restore signal regen at reduced rate
        var signal = GetComponent(BodyComponentType.NerveSignal);
        if (signal != null) signal.RegenRate = 0.1f;

        // Restore mana production at reduced rate
        ManaProductionRate = BaseManaProduction * 0.5f;
    }

    /// <summary>Called when the nerve takes damage — degrades signal quality.</summary>
    public void OnDamaged(float damage)
    {
        GetComponent(BodyComponentType.NerveSignal)?.Decrease(damage * 0.4f);

        // Severe damage impairs mana production
        float healthPct = (GetComponent(BodyComponentType.Health)?.Current ?? 0) / 100f;
        ManaProductionRate = BaseManaProduction * healthPct;
    }

    // ── Resource production (Mana) ─────────────────────────────────

    /// <summary>Produces mana each metabolic tick — the magical energy of the body.</summary>
    public Dictionary<BodyResourceType, float> ProduceResources()
    {
        // No production if severed, disabled, or no signal
        if (IsSevered || Status.HasFlag(SystemNodeStatus.Disabled))
            return [];

        float signalStrength = GetSignalStrength();
        float manaOutput = ManaProductionRate * signalStrength;

        // Accumulate mana on the node itself
        GetComponent(BodyComponentType.Mana)?.Increase(manaOutput);

        // Mana generation produces magical heat — a byproduct the body must dissipate
        float heatGenerated = manaOutput * HeatPerMana;
        GetComponent(BodyComponentType.MagicalHeat)?.Increase(heatGenerated);

        // No global resource production — mana stays on the node
        return [];
    }

    // ── Heat management ────────────────────────────────────────────

    /// <summary>Dissipates heat naturally. Called each metabolic tick.</summary>
    public void DissipateHeat()
    {
        var heat = GetComponent(BodyComponentType.MagicalHeat);
        if (heat == null) return;

        heat.Decrease(HeatDissipationRate);

        // Check overheating state
        if (heat.Current >= HeatDamageThreshold && !IsOverheated)
        {
            IsOverheated = true;
        }
        else if (heat.Current < HeatDamageThreshold * 0.5f && IsOverheated)
        {
            IsOverheated = false;
        }
    }

    /// <summary>
    /// Applies heat damage to the nerve if heat exceeds the damage threshold.
    /// Returns the damage dealt.
    /// </summary>
    public float ApplyHeatDamage()
    {
        var heat = GetComponent(BodyComponentType.MagicalHeat);
        if (heat == null || heat.Current < HeatDamageThreshold) return 0;

        // Damage scales with how far above the threshold the heat is
        float excess = heat.Current - HeatDamageThreshold;
        float damage = excess * 0.3f; // 30% of excess heat becomes nerve damage

        GetComponent(BodyComponentType.Health)?.Decrease(damage);
        GetComponent(BodyComponentType.NerveSignal)?.Decrease(damage * 0.5f);

        // Severe heat impairs mana production (feedback loop — less mana = less heat)
        float healthPct = (GetComponent(BodyComponentType.Health)?.Current ?? 0) / 100f;
        ManaProductionRate = BaseManaProduction * healthPct;

        // Damaged tissue cools worse
        HeatDissipationRate = BaseHeatDissipation * healthPct;

        return damage;
    }
}
